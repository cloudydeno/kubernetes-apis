// Autogenerated Schema file for ResourceV1
import * as c from "../../common.ts";

import * as CoreV1 from "../core@v1/structs.ts";
import * as MetaV1 from "../meta@v1/structs.ts";
type ListOf<T> = {
  metadata: MetaV1.ListMeta;
  items: Array<T>;
};

/** AllocatedDeviceStatus contains the status of an allocated device, if the driver chooses to report it. This may include driver-specific information.

The combination of Driver, Pool, Device, and ShareID must match the corresponding key in Status.Allocation.Devices. */
export interface AllocatedDeviceStatus {
  conditions?: Array<MetaV1.Condition> | null;
  data?: c.JSONValue | null;
  device: string;
  driver: string;
  networkData?: NetworkDeviceData | null;
  pool: string;
  shareID?: string | null;
}
export function toAllocatedDeviceStatus(input: c.JSONValue): AllocatedDeviceStatus {
  const obj = c.checkObj(input);
  return {
    conditions: c.readOpt(obj["conditions"], x => c.readList(x, MetaV1.toCondition)),
    data: c.readOpt(obj["data"], c.identity),
    device: c.checkStr(obj["device"]),
    driver: c.checkStr(obj["driver"]),
    networkData: c.readOpt(obj["networkData"], toNetworkDeviceData),
    pool: c.checkStr(obj["pool"]),
    shareID: c.readOpt(obj["shareID"], c.checkStr),
  }}
export function fromAllocatedDeviceStatus(input: AllocatedDeviceStatus): c.JSONValue {
  return {
    ...input,
    conditions: input.conditions?.map(MetaV1.fromCondition),
    networkData: input.networkData != null ? fromNetworkDeviceData(input.networkData) : undefined,
  }}

/** NetworkDeviceData provides network-related details for the allocated device. This information may be filled by drivers or other components to configure or identify the device within a network context. */
export interface NetworkDeviceData {
  hardwareAddress?: string | null;
  interfaceName?: string | null;
  ips?: Array<string> | null;
}
export function toNetworkDeviceData(input: c.JSONValue): NetworkDeviceData {
  const obj = c.checkObj(input);
  return {
    hardwareAddress: c.readOpt(obj["hardwareAddress"], c.checkStr),
    interfaceName: c.readOpt(obj["interfaceName"], c.checkStr),
    ips: c.readOpt(obj["ips"], x => c.readList(x, c.checkStr)),
  }}
export function fromNetworkDeviceData(input: NetworkDeviceData): c.JSONValue {
  return {
    ...input,
  }}

/** AllocationResult contains attributes of an allocated resource. */
export interface AllocationResult {
  allocationTimestamp?: c.Time | null;
  devices?: DeviceAllocationResult | null;
  nodeSelector?: CoreV1.NodeSelector | null;
}
export function toAllocationResult(input: c.JSONValue): AllocationResult {
  const obj = c.checkObj(input);
  return {
    allocationTimestamp: c.readOpt(obj["allocationTimestamp"], c.toTime),
    devices: c.readOpt(obj["devices"], toDeviceAllocationResult),
    nodeSelector: c.readOpt(obj["nodeSelector"], CoreV1.toNodeSelector),
  }}
export function fromAllocationResult(input: AllocationResult): c.JSONValue {
  return {
    ...input,
    allocationTimestamp: input.allocationTimestamp != null ? c.fromTime(input.allocationTimestamp) : undefined,
    devices: input.devices != null ? fromDeviceAllocationResult(input.devices) : undefined,
    nodeSelector: input.nodeSelector != null ? CoreV1.fromNodeSelector(input.nodeSelector) : undefined,
  }}

/** DeviceAllocationResult is the result of allocating devices. */
export interface DeviceAllocationResult {
  config?: Array<DeviceAllocationConfiguration> | null;
  results?: Array<DeviceRequestAllocationResult> | null;
}
export function toDeviceAllocationResult(input: c.JSONValue): DeviceAllocationResult {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], x => c.readList(x, toDeviceAllocationConfiguration)),
    results: c.readOpt(obj["results"], x => c.readList(x, toDeviceRequestAllocationResult)),
  }}
export function fromDeviceAllocationResult(input: DeviceAllocationResult): c.JSONValue {
  return {
    ...input,
    config: input.config?.map(fromDeviceAllocationConfiguration),
    results: input.results?.map(fromDeviceRequestAllocationResult),
  }}

/** DeviceAllocationConfiguration gets embedded in an AllocationResult. */
export interface DeviceAllocationConfiguration {
  opaque?: OpaqueDeviceConfiguration | null;
  requests?: Array<string> | null;
  source: string;
}
export function toDeviceAllocationConfiguration(input: c.JSONValue): DeviceAllocationConfiguration {
  const obj = c.checkObj(input);
  return {
    opaque: c.readOpt(obj["opaque"], toOpaqueDeviceConfiguration),
    requests: c.readOpt(obj["requests"], x => c.readList(x, c.checkStr)),
    source: c.checkStr(obj["source"]),
  }}
export function fromDeviceAllocationConfiguration(input: DeviceAllocationConfiguration): c.JSONValue {
  return {
    ...input,
    opaque: input.opaque != null ? fromOpaqueDeviceConfiguration(input.opaque) : undefined,
  }}

/** OpaqueDeviceConfiguration contains configuration parameters for a driver in a format defined by the driver vendor. */
export interface OpaqueDeviceConfiguration {
  driver: string;
  parameters: c.JSONValue;
}
export function toOpaqueDeviceConfiguration(input: c.JSONValue): OpaqueDeviceConfiguration {
  const obj = c.checkObj(input);
  return {
    driver: c.checkStr(obj["driver"]),
    parameters: c.identity(obj["parameters"]),
  }}
export function fromOpaqueDeviceConfiguration(input: OpaqueDeviceConfiguration): c.JSONValue {
  return {
    ...input,
  }}

/** DeviceRequestAllocationResult contains the allocation result for one request. */
export interface DeviceRequestAllocationResult {
  adminAccess?: boolean | null;
  bindingConditions?: Array<string> | null;
  bindingFailureConditions?: Array<string> | null;
  consumedCapacity?: Record<string,c.Quantity> | null;
  device: string;
  driver: string;
  pool: string;
  request: string;
  shareID?: string | null;
  tolerations?: Array<DeviceToleration> | null;
}
export function toDeviceRequestAllocationResult(input: c.JSONValue): DeviceRequestAllocationResult {
  const obj = c.checkObj(input);
  return {
    adminAccess: c.readOpt(obj["adminAccess"], c.checkBool),
    bindingConditions: c.readOpt(obj["bindingConditions"], x => c.readList(x, c.checkStr)),
    bindingFailureConditions: c.readOpt(obj["bindingFailureConditions"], x => c.readList(x, c.checkStr)),
    consumedCapacity: c.readOpt(obj["consumedCapacity"], x => c.readMap(x, c.toQuantity)),
    device: c.checkStr(obj["device"]),
    driver: c.checkStr(obj["driver"]),
    pool: c.checkStr(obj["pool"]),
    request: c.checkStr(obj["request"]),
    shareID: c.readOpt(obj["shareID"], c.checkStr),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toDeviceToleration)),
  }}
export function fromDeviceRequestAllocationResult(input: DeviceRequestAllocationResult): c.JSONValue {
  return {
    ...input,
    consumedCapacity: c.writeMap(input.consumedCapacity, c.fromQuantity),
    tolerations: input.tolerations?.map(fromDeviceToleration),
  }}

/** The ResourceClaim this DeviceToleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>. */
export interface DeviceToleration {
  effect?: string | null;
  key?: string | null;
  operator?: string | null;
  tolerationSeconds?: number | null;
  value?: string | null;
}
export function toDeviceToleration(input: c.JSONValue): DeviceToleration {
  const obj = c.checkObj(input);
  return {
    effect: c.readOpt(obj["effect"], c.checkStr),
    key: c.readOpt(obj["key"], c.checkStr),
    operator: c.readOpt(obj["operator"], c.checkStr),
    tolerationSeconds: c.readOpt(obj["tolerationSeconds"], c.checkNum),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function fromDeviceToleration(input: DeviceToleration): c.JSONValue {
  return {
    ...input,
  }}

/** CELDeviceSelector contains a CEL expression for selecting a device. */
export interface CELDeviceSelector {
  expression: string;
}
export function toCELDeviceSelector(input: c.JSONValue): CELDeviceSelector {
  const obj = c.checkObj(input);
  return {
    expression: c.checkStr(obj["expression"]),
  }}
export function fromCELDeviceSelector(input: CELDeviceSelector): c.JSONValue {
  return {
    ...input,
  }}

/** CapacityRequestPolicy defines how requests consume device capacity.

Must not set more than one ValidRequestValues. */
export interface CapacityRequestPolicy {
  default?: c.Quantity | null;
  validRange?: CapacityRequestPolicyRange | null;
  validValues?: Array<c.Quantity> | null;
}
export function toCapacityRequestPolicy(input: c.JSONValue): CapacityRequestPolicy {
  const obj = c.checkObj(input);
  return {
    default: c.readOpt(obj["default"], c.toQuantity),
    validRange: c.readOpt(obj["validRange"], toCapacityRequestPolicyRange),
    validValues: c.readOpt(obj["validValues"], x => c.readList(x, c.toQuantity)),
  }}
export function fromCapacityRequestPolicy(input: CapacityRequestPolicy): c.JSONValue {
  return {
    ...input,
    default: input.default != null ? c.fromQuantity(input.default) : undefined,
    validRange: input.validRange != null ? fromCapacityRequestPolicyRange(input.validRange) : undefined,
    validValues: input.validValues?.map(c.fromQuantity),
  }}

/** CapacityRequestPolicyRange defines a valid range for consumable capacity values.

  - If the requested amount is less than Min, it is rounded up to the Min value.
  - If Step is set and the requested amount is between Min and Max but not aligned with Step,
    it will be rounded up to the next value equal to Min + (n * Step).
  - If Step is not set, the requested amount is used as-is if it falls within the range Min to Max (if set).
  - If the requested or rounded amount exceeds Max (if set), the request does not satisfy the policy,
    and the device cannot be allocated. */
export interface CapacityRequestPolicyRange {
  max?: c.Quantity | null;
  min: c.Quantity;
  step?: c.Quantity | null;
}
export function toCapacityRequestPolicyRange(input: c.JSONValue): CapacityRequestPolicyRange {
  const obj = c.checkObj(input);
  return {
    max: c.readOpt(obj["max"], c.toQuantity),
    min: c.toQuantity(obj["min"]),
    step: c.readOpt(obj["step"], c.toQuantity),
  }}
export function fromCapacityRequestPolicyRange(input: CapacityRequestPolicyRange): c.JSONValue {
  return {
    ...input,
    max: input.max != null ? c.fromQuantity(input.max) : undefined,
    min: input.min != null ? c.fromQuantity(input.min) : undefined,
    step: input.step != null ? c.fromQuantity(input.step) : undefined,
  }}

/** CapacityRequirements defines the capacity requirements for a specific device request. */
export interface CapacityRequirements {
  requests?: Record<string,c.Quantity> | null;
}
export function toCapacityRequirements(input: c.JSONValue): CapacityRequirements {
  const obj = c.checkObj(input);
  return {
    requests: c.readOpt(obj["requests"], x => c.readMap(x, c.toQuantity)),
  }}
export function fromCapacityRequirements(input: CapacityRequirements): c.JSONValue {
  return {
    ...input,
    requests: c.writeMap(input.requests, c.fromQuantity),
  }}

/** Counter describes a quantity associated with a device. */
export interface Counter {
  value: c.Quantity;
}
export function toCounter(input: c.JSONValue): Counter {
  const obj = c.checkObj(input);
  return {
    value: c.toQuantity(obj["value"]),
  }}
export function fromCounter(input: Counter): c.JSONValue {
  return {
    ...input,
    value: input.value != null ? c.fromQuantity(input.value) : undefined,
  }}

/** CounterSet defines a named set of counters that are available to be used by devices defined in the ResourceSlice.

The counters are not allocatable by themselves, but can be referenced by devices. When a device is allocated, the portion of counters it uses will no longer be available for use by other devices. */
export interface CounterSet {
  counters: Record<string,Counter>;
  name: string;
}
export function toCounterSet(input: c.JSONValue): CounterSet {
  const obj = c.checkObj(input);
  return {
    counters: c.readMap(obj["counters"], toCounter),
    name: c.checkStr(obj["name"]),
  }}
export function fromCounterSet(input: CounterSet): c.JSONValue {
  return {
    ...input,
    counters: c.writeMap(input.counters, fromCounter),
  }}

/** Device represents one individual hardware instance that can be selected based on its attributes. Besides the name, exactly one field must be set. */
export interface Device {
  allNodes?: boolean | null;
  allowMultipleAllocations?: boolean | null;
  attributes?: Record<string,DeviceAttribute> | null;
  bindingConditions?: Array<string> | null;
  bindingFailureConditions?: Array<string> | null;
  bindsToNode?: boolean | null;
  capacity?: Record<string,DeviceCapacity> | null;
  consumesCounters?: Array<DeviceCounterConsumption> | null;
  name: string;
  nodeName?: string | null;
  nodeSelector?: CoreV1.NodeSelector | null;
  taints?: Array<DeviceTaint> | null;
}
export function toDevice(input: c.JSONValue): Device {
  const obj = c.checkObj(input);
  return {
    allNodes: c.readOpt(obj["allNodes"], c.checkBool),
    allowMultipleAllocations: c.readOpt(obj["allowMultipleAllocations"], c.checkBool),
    attributes: c.readOpt(obj["attributes"], x => c.readMap(x, toDeviceAttribute)),
    bindingConditions: c.readOpt(obj["bindingConditions"], x => c.readList(x, c.checkStr)),
    bindingFailureConditions: c.readOpt(obj["bindingFailureConditions"], x => c.readList(x, c.checkStr)),
    bindsToNode: c.readOpt(obj["bindsToNode"], c.checkBool),
    capacity: c.readOpt(obj["capacity"], x => c.readMap(x, toDeviceCapacity)),
    consumesCounters: c.readOpt(obj["consumesCounters"], x => c.readList(x, toDeviceCounterConsumption)),
    name: c.checkStr(obj["name"]),
    nodeName: c.readOpt(obj["nodeName"], c.checkStr),
    nodeSelector: c.readOpt(obj["nodeSelector"], CoreV1.toNodeSelector),
    taints: c.readOpt(obj["taints"], x => c.readList(x, toDeviceTaint)),
  }}
export function fromDevice(input: Device): c.JSONValue {
  return {
    ...input,
    attributes: c.writeMap(input.attributes, fromDeviceAttribute),
    capacity: c.writeMap(input.capacity, fromDeviceCapacity),
    consumesCounters: input.consumesCounters?.map(fromDeviceCounterConsumption),
    nodeSelector: input.nodeSelector != null ? CoreV1.fromNodeSelector(input.nodeSelector) : undefined,
    taints: input.taints?.map(fromDeviceTaint),
  }}

/** DeviceAttribute must have exactly one field set. */
export interface DeviceAttribute {
  bool?: boolean | null;
  int?: number | null;
  string?: string | null;
  version?: string | null;
}
export function toDeviceAttribute(input: c.JSONValue): DeviceAttribute {
  const obj = c.checkObj(input);
  return {
    bool: c.readOpt(obj["bool"], c.checkBool),
    int: c.readOpt(obj["int"], c.checkNum),
    string: c.readOpt(obj["string"], c.checkStr),
    version: c.readOpt(obj["version"], c.checkStr),
  }}
export function fromDeviceAttribute(input: DeviceAttribute): c.JSONValue {
  return {
    ...input,
  }}

/** DeviceCapacity describes a quantity associated with a device. */
export interface DeviceCapacity {
  requestPolicy?: CapacityRequestPolicy | null;
  value: c.Quantity;
}
export function toDeviceCapacity(input: c.JSONValue): DeviceCapacity {
  const obj = c.checkObj(input);
  return {
    requestPolicy: c.readOpt(obj["requestPolicy"], toCapacityRequestPolicy),
    value: c.toQuantity(obj["value"]),
  }}
export function fromDeviceCapacity(input: DeviceCapacity): c.JSONValue {
  return {
    ...input,
    requestPolicy: input.requestPolicy != null ? fromCapacityRequestPolicy(input.requestPolicy) : undefined,
    value: input.value != null ? c.fromQuantity(input.value) : undefined,
  }}

/** DeviceCounterConsumption defines a set of counters that a device will consume from a CounterSet. */
export interface DeviceCounterConsumption {
  counterSet: string;
  counters: Record<string,Counter>;
}
export function toDeviceCounterConsumption(input: c.JSONValue): DeviceCounterConsumption {
  const obj = c.checkObj(input);
  return {
    counterSet: c.checkStr(obj["counterSet"]),
    counters: c.readMap(obj["counters"], toCounter),
  }}
export function fromDeviceCounterConsumption(input: DeviceCounterConsumption): c.JSONValue {
  return {
    ...input,
    counters: c.writeMap(input.counters, fromCounter),
  }}

/** The device this taint is attached to has the "effect" on any claim which does not tolerate the taint and, through the claim, to pods using the claim. */
export interface DeviceTaint {
  effect: string;
  key: string;
  timeAdded?: c.Time | null;
  value?: string | null;
}
export function toDeviceTaint(input: c.JSONValue): DeviceTaint {
  const obj = c.checkObj(input);
  return {
    effect: c.checkStr(obj["effect"]),
    key: c.checkStr(obj["key"]),
    timeAdded: c.readOpt(obj["timeAdded"], c.toTime),
    value: c.readOpt(obj["value"], c.checkStr),
  }}
export function fromDeviceTaint(input: DeviceTaint): c.JSONValue {
  return {
    ...input,
    timeAdded: input.timeAdded != null ? c.fromTime(input.timeAdded) : undefined,
  }}

/** DeviceClaim defines how to request devices with a ResourceClaim. */
export interface DeviceClaim {
  config?: Array<DeviceClaimConfiguration> | null;
  constraints?: Array<DeviceConstraint> | null;
  requests?: Array<DeviceRequest> | null;
}
export function toDeviceClaim(input: c.JSONValue): DeviceClaim {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], x => c.readList(x, toDeviceClaimConfiguration)),
    constraints: c.readOpt(obj["constraints"], x => c.readList(x, toDeviceConstraint)),
    requests: c.readOpt(obj["requests"], x => c.readList(x, toDeviceRequest)),
  }}
export function fromDeviceClaim(input: DeviceClaim): c.JSONValue {
  return {
    ...input,
    config: input.config?.map(fromDeviceClaimConfiguration),
    constraints: input.constraints?.map(fromDeviceConstraint),
    requests: input.requests?.map(fromDeviceRequest),
  }}

/** DeviceClaimConfiguration is used for configuration parameters in DeviceClaim. */
export interface DeviceClaimConfiguration {
  opaque?: OpaqueDeviceConfiguration | null;
  requests?: Array<string> | null;
}
export function toDeviceClaimConfiguration(input: c.JSONValue): DeviceClaimConfiguration {
  const obj = c.checkObj(input);
  return {
    opaque: c.readOpt(obj["opaque"], toOpaqueDeviceConfiguration),
    requests: c.readOpt(obj["requests"], x => c.readList(x, c.checkStr)),
  }}
export function fromDeviceClaimConfiguration(input: DeviceClaimConfiguration): c.JSONValue {
  return {
    ...input,
    opaque: input.opaque != null ? fromOpaqueDeviceConfiguration(input.opaque) : undefined,
  }}

/** DeviceConstraint must have exactly one field set besides Requests. */
export interface DeviceConstraint {
  distinctAttribute?: string | null;
  matchAttribute?: string | null;
  requests?: Array<string> | null;
}
export function toDeviceConstraint(input: c.JSONValue): DeviceConstraint {
  const obj = c.checkObj(input);
  return {
    distinctAttribute: c.readOpt(obj["distinctAttribute"], c.checkStr),
    matchAttribute: c.readOpt(obj["matchAttribute"], c.checkStr),
    requests: c.readOpt(obj["requests"], x => c.readList(x, c.checkStr)),
  }}
export function fromDeviceConstraint(input: DeviceConstraint): c.JSONValue {
  return {
    ...input,
  }}

/** DeviceRequest is a request for devices required for a claim. This is typically a request for a single resource like a device, but can also ask for several identical devices. With FirstAvailable it is also possible to provide a prioritized list of requests. */
export interface DeviceRequest {
  exactly?: ExactDeviceRequest | null;
  firstAvailable?: Array<DeviceSubRequest> | null;
  name: string;
}
export function toDeviceRequest(input: c.JSONValue): DeviceRequest {
  const obj = c.checkObj(input);
  return {
    exactly: c.readOpt(obj["exactly"], toExactDeviceRequest),
    firstAvailable: c.readOpt(obj["firstAvailable"], x => c.readList(x, toDeviceSubRequest)),
    name: c.checkStr(obj["name"]),
  }}
export function fromDeviceRequest(input: DeviceRequest): c.JSONValue {
  return {
    ...input,
    exactly: input.exactly != null ? fromExactDeviceRequest(input.exactly) : undefined,
    firstAvailable: input.firstAvailable?.map(fromDeviceSubRequest),
  }}

/** ExactDeviceRequest is a request for one or more identical devices. */
export interface ExactDeviceRequest {
  adminAccess?: boolean | null;
  allocationMode?: string | null;
  capacity?: CapacityRequirements | null;
  count?: number | null;
  deviceClassName: string;
  selectors?: Array<DeviceSelector> | null;
  tolerations?: Array<DeviceToleration> | null;
}
export function toExactDeviceRequest(input: c.JSONValue): ExactDeviceRequest {
  const obj = c.checkObj(input);
  return {
    adminAccess: c.readOpt(obj["adminAccess"], c.checkBool),
    allocationMode: c.readOpt(obj["allocationMode"], c.checkStr),
    capacity: c.readOpt(obj["capacity"], toCapacityRequirements),
    count: c.readOpt(obj["count"], c.checkNum),
    deviceClassName: c.checkStr(obj["deviceClassName"]),
    selectors: c.readOpt(obj["selectors"], x => c.readList(x, toDeviceSelector)),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toDeviceToleration)),
  }}
export function fromExactDeviceRequest(input: ExactDeviceRequest): c.JSONValue {
  return {
    ...input,
    capacity: input.capacity != null ? fromCapacityRequirements(input.capacity) : undefined,
    selectors: input.selectors?.map(fromDeviceSelector),
    tolerations: input.tolerations?.map(fromDeviceToleration),
  }}

/** DeviceSelector must have exactly one field set. */
export interface DeviceSelector {
  cel?: CELDeviceSelector | null;
}
export function toDeviceSelector(input: c.JSONValue): DeviceSelector {
  const obj = c.checkObj(input);
  return {
    cel: c.readOpt(obj["cel"], toCELDeviceSelector),
  }}
export function fromDeviceSelector(input: DeviceSelector): c.JSONValue {
  return {
    ...input,
    cel: input.cel != null ? fromCELDeviceSelector(input.cel) : undefined,
  }}

/** DeviceSubRequest describes a request for device provided in the claim.spec.devices.requests[].firstAvailable array. Each is typically a request for a single resource like a device, but can also ask for several identical devices.

DeviceSubRequest is similar to ExactDeviceRequest, but doesn't expose the AdminAccess field as that one is only supported when requesting a specific device. */
export interface DeviceSubRequest {
  allocationMode?: string | null;
  capacity?: CapacityRequirements | null;
  count?: number | null;
  deviceClassName: string;
  name: string;
  selectors?: Array<DeviceSelector> | null;
  tolerations?: Array<DeviceToleration> | null;
}
export function toDeviceSubRequest(input: c.JSONValue): DeviceSubRequest {
  const obj = c.checkObj(input);
  return {
    allocationMode: c.readOpt(obj["allocationMode"], c.checkStr),
    capacity: c.readOpt(obj["capacity"], toCapacityRequirements),
    count: c.readOpt(obj["count"], c.checkNum),
    deviceClassName: c.checkStr(obj["deviceClassName"]),
    name: c.checkStr(obj["name"]),
    selectors: c.readOpt(obj["selectors"], x => c.readList(x, toDeviceSelector)),
    tolerations: c.readOpt(obj["tolerations"], x => c.readList(x, toDeviceToleration)),
  }}
export function fromDeviceSubRequest(input: DeviceSubRequest): c.JSONValue {
  return {
    ...input,
    capacity: input.capacity != null ? fromCapacityRequirements(input.capacity) : undefined,
    selectors: input.selectors?.map(fromDeviceSelector),
    tolerations: input.tolerations?.map(fromDeviceToleration),
  }}

/** DeviceClass is a vendor- or admin-provided resource that contains device configuration and selectors. It can be referenced in the device requests of a claim to apply these presets. Cluster scoped.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface DeviceClass {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "DeviceClass";
  metadata?: MetaV1.ObjectMeta | null;
  spec: DeviceClassSpec;
}
export function toDeviceClass(input: c.JSONValue): DeviceClass & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "DeviceClass"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toDeviceClassSpec(obj["spec"]),
  }}
export function fromDeviceClass(input: DeviceClass): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1", "DeviceClass"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromDeviceClassSpec(input.spec) : undefined,
  }}

/** DeviceClassSpec is used in a [DeviceClass] to define what can be allocated and how to configure it. */
export interface DeviceClassSpec {
  config?: Array<DeviceClassConfiguration> | null;
  extendedResourceName?: string | null;
  selectors?: Array<DeviceSelector> | null;
}
export function toDeviceClassSpec(input: c.JSONValue): DeviceClassSpec {
  const obj = c.checkObj(input);
  return {
    config: c.readOpt(obj["config"], x => c.readList(x, toDeviceClassConfiguration)),
    extendedResourceName: c.readOpt(obj["extendedResourceName"], c.checkStr),
    selectors: c.readOpt(obj["selectors"], x => c.readList(x, toDeviceSelector)),
  }}
export function fromDeviceClassSpec(input: DeviceClassSpec): c.JSONValue {
  return {
    ...input,
    config: input.config?.map(fromDeviceClassConfiguration),
    selectors: input.selectors?.map(fromDeviceSelector),
  }}

/** DeviceClassConfiguration is used in DeviceClass. */
export interface DeviceClassConfiguration {
  opaque?: OpaqueDeviceConfiguration | null;
}
export function toDeviceClassConfiguration(input: c.JSONValue): DeviceClassConfiguration {
  const obj = c.checkObj(input);
  return {
    opaque: c.readOpt(obj["opaque"], toOpaqueDeviceConfiguration),
  }}
export function fromDeviceClassConfiguration(input: DeviceClassConfiguration): c.JSONValue {
  return {
    ...input,
    opaque: input.opaque != null ? fromOpaqueDeviceConfiguration(input.opaque) : undefined,
  }}

/** DeviceClassList is a collection of classes. */
export interface DeviceClassList extends ListOf<DeviceClass> {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "DeviceClassList";
};
export function toDeviceClassList(input: c.JSONValue): DeviceClassList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "DeviceClassList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toDeviceClass),
  }}

/** ResourceClaim describes a request for access to resources in the cluster, for use by workloads. For example, if a workload needs an accelerator device with specific properties, this is how that request is expressed. The status stanza tracks whether this claim has been satisfied and what specific resources have been allocated.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClaim {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "ResourceClaim";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
  status?: ResourceClaimStatus | null;
}
export function toResourceClaim(input: c.JSONValue): ResourceClaim & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "ResourceClaim"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
    status: c.readOpt(obj["status"], toResourceClaimStatus),
  }}
export function fromResourceClaim(input: ResourceClaim): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1", "ResourceClaim"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
    status: input.status != null ? fromResourceClaimStatus(input.status) : undefined,
  }}

/** ResourceClaimSpec defines what is being requested in a ResourceClaim and how to configure it. */
export interface ResourceClaimSpec {
  devices?: DeviceClaim | null;
}
export function toResourceClaimSpec(input: c.JSONValue): ResourceClaimSpec {
  const obj = c.checkObj(input);
  return {
    devices: c.readOpt(obj["devices"], toDeviceClaim),
  }}
export function fromResourceClaimSpec(input: ResourceClaimSpec): c.JSONValue {
  return {
    ...input,
    devices: input.devices != null ? fromDeviceClaim(input.devices) : undefined,
  }}

/** ResourceClaimStatus tracks whether the resource has been allocated and what the result of that was. */
export interface ResourceClaimStatus {
  allocation?: AllocationResult | null;
  devices?: Array<AllocatedDeviceStatus> | null;
  reservedFor?: Array<ResourceClaimConsumerReference> | null;
}
export function toResourceClaimStatus(input: c.JSONValue): ResourceClaimStatus {
  const obj = c.checkObj(input);
  return {
    allocation: c.readOpt(obj["allocation"], toAllocationResult),
    devices: c.readOpt(obj["devices"], x => c.readList(x, toAllocatedDeviceStatus)),
    reservedFor: c.readOpt(obj["reservedFor"], x => c.readList(x, toResourceClaimConsumerReference)),
  }}
export function fromResourceClaimStatus(input: ResourceClaimStatus): c.JSONValue {
  return {
    ...input,
    allocation: input.allocation != null ? fromAllocationResult(input.allocation) : undefined,
    devices: input.devices?.map(fromAllocatedDeviceStatus),
    reservedFor: input.reservedFor?.map(fromResourceClaimConsumerReference),
  }}

/** ResourceClaimConsumerReference contains enough information to let you locate the consumer of a ResourceClaim. The user must be a resource in the same namespace as the ResourceClaim. */
export interface ResourceClaimConsumerReference {
  apiGroup?: string | null;
  name: string;
  resource: string;
  uid: string;
}
export function toResourceClaimConsumerReference(input: c.JSONValue): ResourceClaimConsumerReference {
  const obj = c.checkObj(input);
  return {
    apiGroup: c.readOpt(obj["apiGroup"], c.checkStr),
    name: c.checkStr(obj["name"]),
    resource: c.checkStr(obj["resource"]),
    uid: c.checkStr(obj["uid"]),
  }}
export function fromResourceClaimConsumerReference(input: ResourceClaimConsumerReference): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceClaimList is a collection of claims. */
export interface ResourceClaimList extends ListOf<ResourceClaim> {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "ResourceClaimList";
};
export function toResourceClaimList(input: c.JSONValue): ResourceClaimList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "ResourceClaimList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaim),
  }}

/** ResourceClaimTemplate is used to produce ResourceClaim objects.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceClaimTemplate {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "ResourceClaimTemplate";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimTemplateSpec;
}
export function toResourceClaimTemplate(input: c.JSONValue): ResourceClaimTemplate & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "ResourceClaimTemplate"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimTemplateSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplate(input: ResourceClaimTemplate): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1", "ResourceClaimTemplate"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimTemplateSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateSpec contains the metadata and fields for a ResourceClaim. */
export interface ResourceClaimTemplateSpec {
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceClaimSpec;
}
export function toResourceClaimTemplateSpec(input: c.JSONValue): ResourceClaimTemplateSpec {
  const obj = c.checkObj(input);
  return {
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceClaimSpec(obj["spec"]),
  }}
export function fromResourceClaimTemplateSpec(input: ResourceClaimTemplateSpec): c.JSONValue {
  return {
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceClaimSpec(input.spec) : undefined,
  }}

/** ResourceClaimTemplateList is a collection of claim templates. */
export interface ResourceClaimTemplateList extends ListOf<ResourceClaimTemplate> {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "ResourceClaimTemplateList";
};
export function toResourceClaimTemplateList(input: c.JSONValue): ResourceClaimTemplateList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "ResourceClaimTemplateList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceClaimTemplate),
  }}

/** ResourcePool describes the pool that ResourceSlices belong to. */
export interface ResourcePool {
  generation: number;
  name: string;
  resourceSliceCount: number;
}
export function toResourcePool(input: c.JSONValue): ResourcePool {
  const obj = c.checkObj(input);
  return {
    generation: c.checkNum(obj["generation"]),
    name: c.checkStr(obj["name"]),
    resourceSliceCount: c.checkNum(obj["resourceSliceCount"]),
  }}
export function fromResourcePool(input: ResourcePool): c.JSONValue {
  return {
    ...input,
  }}

/** ResourceSlice represents one or more resources in a pool of similar resources, managed by a common driver. A pool may span more than one ResourceSlice, and exactly how many ResourceSlices comprise a pool is determined by the driver.

At the moment, the only supported resources are devices with attributes and capacities. Each device in a given pool, regardless of how many ResourceSlices, must have a unique name. The ResourceSlice in which a device gets published may change over time. The unique identifier for a device is the tuple <driver name>, <pool name>, <device name>.

Whenever a driver needs to update a pool, it increments the pool.Spec.Pool.Generation number and updates all ResourceSlices with that new number and new resource definitions. A consumer must only use ResourceSlices with the highest generation number and ignore all others.

When allocating all resources in a pool matching certain criteria or when looking for the best solution among several different alternatives, a consumer should check the number of ResourceSlices in a pool (included in each ResourceSlice) to determine whether its view of a pool is complete and if not, should wait until the driver has completed updating the pool.

For resources that are not local to a node, the node name is not set. Instead, the driver may use a node selector to specify where the devices are available.

This is an alpha type and requires enabling the DynamicResourceAllocation feature gate. */
export interface ResourceSlice {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "ResourceSlice";
  metadata?: MetaV1.ObjectMeta | null;
  spec: ResourceSliceSpec;
}
export function toResourceSlice(input: c.JSONValue): ResourceSlice & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "ResourceSlice"),
    metadata: c.readOpt(obj["metadata"], MetaV1.toObjectMeta),
    spec: toResourceSliceSpec(obj["spec"]),
  }}
export function fromResourceSlice(input: ResourceSlice): c.JSONValue {
  return {
    ...c.assertOrAddApiVersionAndKind(input, "resource.k8s.io/v1", "ResourceSlice"),
    ...input,
    metadata: input.metadata != null ? MetaV1.fromObjectMeta(input.metadata) : undefined,
    spec: input.spec != null ? fromResourceSliceSpec(input.spec) : undefined,
  }}

/** ResourceSliceSpec contains the information published by the driver in one ResourceSlice. */
export interface ResourceSliceSpec {
  allNodes?: boolean | null;
  devices?: Array<Device> | null;
  driver: string;
  nodeName?: string | null;
  nodeSelector?: CoreV1.NodeSelector | null;
  perDeviceNodeSelection?: boolean | null;
  pool: ResourcePool;
  sharedCounters?: Array<CounterSet> | null;
}
export function toResourceSliceSpec(input: c.JSONValue): ResourceSliceSpec {
  const obj = c.checkObj(input);
  return {
    allNodes: c.readOpt(obj["allNodes"], c.checkBool),
    devices: c.readOpt(obj["devices"], x => c.readList(x, toDevice)),
    driver: c.checkStr(obj["driver"]),
    nodeName: c.readOpt(obj["nodeName"], c.checkStr),
    nodeSelector: c.readOpt(obj["nodeSelector"], CoreV1.toNodeSelector),
    perDeviceNodeSelection: c.readOpt(obj["perDeviceNodeSelection"], c.checkBool),
    pool: toResourcePool(obj["pool"]),
    sharedCounters: c.readOpt(obj["sharedCounters"], x => c.readList(x, toCounterSet)),
  }}
export function fromResourceSliceSpec(input: ResourceSliceSpec): c.JSONValue {
  return {
    ...input,
    devices: input.devices?.map(fromDevice),
    nodeSelector: input.nodeSelector != null ? CoreV1.fromNodeSelector(input.nodeSelector) : undefined,
    pool: input.pool != null ? fromResourcePool(input.pool) : undefined,
    sharedCounters: input.sharedCounters?.map(fromCounterSet),
  }}

/** ResourceSliceList is a collection of ResourceSlices. */
export interface ResourceSliceList extends ListOf<ResourceSlice> {
  apiVersion?: "resource.k8s.io/v1";
  kind?: "ResourceSliceList";
};
export function toResourceSliceList(input: c.JSONValue): ResourceSliceList & c.ApiKind {
  const obj = c.checkObj(input);
  return {
    ...c.assertOrAddApiVersionAndKind(obj, "resource.k8s.io/v1", "ResourceSliceList"),
    metadata: MetaV1.toListMeta(obj.metadata),
    items: c.readList(obj.items, toResourceSlice),
  }}
